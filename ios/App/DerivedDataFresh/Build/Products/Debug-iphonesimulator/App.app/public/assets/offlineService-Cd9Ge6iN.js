import{s as p}from"./index-BcNl-kiB.js";import"./framer-CcO5Kjcw.js";import"./router-ClfHAwMg.js";import"./react-vendor-B--z-fyW.js";import"./supabase-CIvuJI4W.js";import"./icons-Dvxa2Qho.js";const x="idoneo-offline-db",j=1,b="questions",w="quiz_meta",a="pending_attempts",z={async openDB(){return new Promise((o,i)=>{const t=indexedDB.open(x,j);t.onerror=()=>i(t.error),t.onsuccess=()=>o(t.result),t.onupgradeneeded=c=>{const s=c.target.result;s.objectStoreNames.contains(b)||s.createObjectStore(b,{keyPath:"id"}),s.objectStoreNames.contains(w)||s.createObjectStore(w,{keyPath:"id"}),s.objectStoreNames.contains(a)||s.createObjectStore(a,{keyPath:"localId"})}})},async downloadQuiz(o,i){const{data:t,error:c}=await p.from("quizzes").select("id, title, description").eq("id",o).single();if(c||!t)throw new Error("Quiz not found online");const{data:s}=await p.from("quiz_subject_rules").select("id, subject_id, question_count").eq("quiz_id",o);if(!s||s.length===0)throw new Error("No structure found for quiz");const e=s.map(l=>l.subject_id).filter(Boolean);let n=[];const d=500,{count:r}=await p.from("questions").select("id",{count:"exact",head:!0}).in("subject_id",e),u=r||0;let m=0,f=0;for(;;){const{data:l,error:S}=await p.from("questions").select("id, text, options, correct_option, explanation, subject_id").in("subject_id",e).range(f,f+d-1);if(S)throw S;if(!l||l.length===0||(n=[...n,...l],m+=l.length,f+=d,i&&u>0&&i(Math.round(m/u*100)),l.length<d))break}const h=(await this.openDB()).transaction([b,w],"readwrite"),_=h.objectStore(b);for(const l of n)_.put(l);const g=h.objectStore(w),y={id:o,title:t.title,description:t.description,questionIds:n.map(l=>l.id),timestamp:Date.now()};return g.put(y),new Promise((l,S)=>{h.oncomplete=()=>l(),h.onerror=()=>S(h.error)})},async isQuizDownloaded(o){try{const i=await this.openDB();return new Promise(t=>{const e=i.transaction(w,"readonly").objectStore(w).get(o);e.onsuccess=()=>t(!!e.result),e.onerror=()=>t(!1)})}catch{return!1}},async getQuestions(o){const c=(await this.openDB()).transaction(b,"readonly").objectStore(b),s=[];for(const e of o)try{const n=await new Promise((d,r)=>{const u=c.get(e);u.onsuccess=()=>d(u.result),u.onerror=()=>r(u.error)});n&&s.push(n)}catch{console.warn(`Missing offline question: ${e}`)}return s},async generateOfflineReview(o,i){const t=await this.openDB(),c=await new Promise((e,n)=>{const r=t.transaction(w,"readonly").objectStore(w).get(o);r.onsuccess=()=>e(r.result),r.onerror=()=>n(r.error)});if(!c||!c.questionIds)return[];const s=c.questionIds.sort(()=>.5-Math.random()).slice(0,i);return this.getQuestions(s)},async savePendingAttempt(o){const t=(await this.openDB()).transaction(a,"readwrite"),c=t.objectStore(a);return o.updated_at||(o.updated_at=new Date().toISOString()),o.created_at||(o.created_at=new Date().toISOString()),o.synced=!1,c.put(o),new Promise((s,e)=>{t.oncomplete=()=>s(),t.onerror=()=>e(t.error)})},async createLocalAttempt(o){const t=(await this.openDB()).transaction(a,"readwrite"),c=t.objectStore(a),e=(await this.generateOfflineReview(o,20)).map(r=>({questionId:r.id,text:r.text,options:r.options,correctOption:r.correct_option,explanation:r.explanation,selectedOption:null,subjectId:r.subject_id})),n=`local-${Date.now()}`,d={id:n,localId:n,quiz_id:o,status:"in_progress",created_at:new Date().toISOString(),answers:e,synced:!1};return c.put(d),new Promise((r,u)=>{t.oncomplete=()=>r(n),t.onerror=()=>u(t.error)})},async getLocalAttempt(o){const i=await this.openDB();return new Promise((t,c)=>{const n=i.transaction(a,"readonly").objectStore(a).get(o);n.onsuccess=()=>t(n.result),n.onerror=()=>c(n.error)})},async syncPendingAttempts(){const{data:{user:o}}=await p.auth.getUser();if(!o)return 0;const i=await this.openDB(),t=await new Promise((e,n)=>{const r=i.transaction(a,"readonly").objectStore(a).getAll();r.onsuccess=()=>e(r.result),r.onerror=()=>n(r.error)});if(t.length===0)return 0;let c=0;i.transaction(a,"readwrite").objectStore(a);for(const e of t){if(!e.finished_at)continue;const{localId:n,synced:d,id:r,...u}=e,m={...u,user_id:o.id},{error:f}=await p.from("quiz_attempts").insert(m);f?console.error("Sync error for attempt",e.localId,f):c++}if(c>0){i.transaction(a,"readwrite").objectStore(a);for(const n of t)n.finished_at}return c},async syncAndClean(){const{data:{user:o}}=await p.auth.getUser();if(!o)return 0;const i=await this.openDB(),t=await new Promise(e=>{const d=i.transaction(a,"readonly").objectStore(a);d.getAll().onsuccess=r=>e(r.target.result)});let c=0;const s=[];for(const e of t){if(!e.finished_at)continue;const{localId:n,synced:d,id:r,...u}=e,m={...u,user_id:o.id},{error:f}=await p.from("quiz_attempts").insert(m);f||(s.push(e.localId),c++)}if(s.length>0){const e=i.transaction(a,"readwrite"),n=e.objectStore(a);s.forEach(d=>n.delete(d)),await new Promise(d=>{e.oncomplete=()=>d()})}return c}};export{z as offlineService};
